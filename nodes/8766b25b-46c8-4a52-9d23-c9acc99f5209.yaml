id: 8766b25b-46c8-4a52-9d23-c9acc99f5209
template: mcpServer
config:
  title: codex tools
  namespace: codex
  command: " curl -fsSL https://github.com/HautechAI/codex-tools-mcp/releases/download/v0.1.0/codex-tools-mcp__linux_arm64.tar.gz -o codex-tools-mcp.tar.gz && tar -xzf codex-tools-mcp.tar.gz && chmod +x codex-tools-mcp && rm -f codex-tools-mcp.tar.gz && ./codex-tools-mcp"
  env: []
  requestTimeoutMs: 20000
  startupTimeoutMs: 20000
  restart:
    maxAttempts: 5
    backoffMs: 2000
  heartbeatIntervalMs: 300000
  staleTimeoutMs: 0
state:
  mcp:
    tools:
      - name: update_plan
        description: Updates the task plan. Provide an optional explanation and a list of plan items, each with a step and status. At most one step can be in_progress at a time.
        inputSchema:
          type: object
          properties:
            explanation:
              type: string
            plan:
              description: The list of steps
              items:
                additionalProperties: false
                properties:
                  status:
                    description: "One of: pending, in_progress, completed"
                    type: string
                  step:
                    type: string
                required:
                  - step
                  - status
                type: object
              type: array
          required:
            - plan
          additionalProperties: false
      - name: apply_patch
        description: |-
          Use the `apply_patch` tool to edit files.
          Your patch language is a stripped-down, file-oriented diff format designed to be easy to parse and safe to apply. You can think of it as a high-level envelope:

          *** Begin Patch
          [ one or more file sections ]
          *** End Patch

          Within that envelope, you get a sequence of file operations.
          You MUST include a header to specify the action you are taking.
          Each operation starts with one of three headers:

          *** Add File: <path> - create a new file. Every following line is a + line (the initial contents).
          *** Delete File: <path> - remove an existing file. Nothing follows.
          *** Update File: <path> - patch an existing file in place (optionally with a rename).

          May be immediately followed by *** Move to: <new path> if you want to rename the file.
          Then one or more “hunks”, each introduced by @@ (optionally followed by a hunk header).
          Within a hunk each line starts with:

          For instructions on [context_before] and [context_after]:
          - By default, show 3 lines of code immediately above and 3 lines immediately below each change. If a change is within 3 lines of a previous change, do NOT duplicate the first change’s [context_after] lines in the second change’s [context_before] lines.
          - If 3 lines of context is insufficient to uniquely identify the snippet of code within the file, use the @@ operator to indicate the class or function to which the snippet belongs. For instance, we might have:
          @@ class BaseClass
          [3 lines of pre-context]
          - [old_code]
          + [new_code]
          [3 lines of post-context]

          - If a code block is repeated so many times in a class or function such that even a single `@@` statement and 3 lines of context cannot uniquely identify the snippet of code, you can use multiple `@@` statements to jump to the right context. For instance:

          @@ class BaseClass
          @@ 	 def method():
          [3 lines of pre-context]
          - [old_code]
          + [new_code]
          [3 lines of post-context]

          The full grammar definition is below:
          Patch := Begin { FileOp } End
          Begin := "*** Begin Patch" NEWLINE
          End := "*** End Patch" NEWLINE
          FileOp := AddFile | DeleteFile | UpdateFile
          AddFile := "*** Add File: " path NEWLINE { "+" line NEWLINE }
          DeleteFile := "*** Delete File: " path NEWLINE
          UpdateFile := "*** Update File: " path NEWLINE [ MoveTo ] { Hunk }
          MoveTo := "*** Move to: " newPath NEWLINE
          Hunk := "@@" [ header ] NEWLINE { HunkLine } [ "*** End of File" NEWLINE ]
          HunkLine := (" " | "-" | "+") text NEWLINE

          A full patch can combine several operations:

          *** Begin Patch
          *** Add File: hello.txt
          +Hello world
          *** Update File: src/app.py
          *** Move to: src/main.py
          @@ def greet():
          -print("Hi")
          +print("Hello, world!")
          *** Delete File: obsolete.txt
          *** End Patch

          It is important to remember:

          - You must include a header with your intended action (Add/Delete/Update)
          - You must prefix new lines with `+` even when creating a new file
          - File references can only be relative, NEVER ABSOLUTE.
        inputSchema:
          type: object
          properties:
            input:
              description: The entire contents of the apply_patch command
              type: string
          required:
            - input
          additionalProperties: false
    toolsUpdatedAt: 1763217097202
    enabledTools:
      - update_plan
      - apply_patch
position:
  x: 720.6316291282105
  y: -894.3735596801316
